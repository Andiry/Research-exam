\section{Future Work} 
\label{sec:future}

NVMM brings us with fast, dense,
non-volatile, and byte-addressable memory. With these properties NVMM may
replace DRAM or slower storage in the future.
This may greatly change the current DRAM/storage
hierarchy and impact the system software design.

If NVMM replace DRAM entirely, all the programs will be executed on a
persistence address space, and whole system persistency is available~\cite{WSP}.
This may reduce system recovery time to seconds and programs can resume
running form where they are interrupted. However, putting everything in
NVMM also has risk. A malicious attack can break the application data, and if
the operating system cannot detect the attack, applications may never run
properly again, as writing to NVMM is persistent and cannot be fixed by a reboot. 

On the other hand, if NVMM replace the slower storage devices, the DRAM/storage
architecture need to be redesigned. Several common operating system features
may be obsoleted or needs modficiation:
\begin{itemize}
\item Is file system still necessary?
Disks and other storage devices do not provide any
protection mechanism and rely on file system to protect the data, but NVMM
can be protected by MMU hardware.
\item Block layer and I/O scheduling
will be eliminated as they are designed for disks,
while NVMM is byte-addressable and supports random access.
\item DRAM cache (page cache and buffer cache) does not exist anymore. If data
is reside in NVMM, there is no point to cache it in DRAM. All the load/store
operations should go to NVMM directly.
\item We need to think about POSIX APIs again. For years applications use
\texttt{open()} to open a file, and call \texttt{read()} and \texttt{write()} to
access the file data. As NVMM can be accessed via load/store operations, 
POSIX read and write may adds unnecessary overheads to file access.
 As pointed out in Section~\ref{sec:noposix}, current POSIX file 
interface may impace performance when accessing data on NVMM.
\end{itemize}

Also, POSIX APIs trigger system calls, which results in mode switch overheads.
This is not a problem when access slow storage devices, but for fast NVMM things
are different.
Researchers have realized the software overheads could impact
fast storage and networking device performance,
and they have proposed different approaches to make the common path as fast
as possible.
Arrakis~\cite{Arrakis} and IX~\cite{IX} argues that seperating data plane
from control plane could improve application performance by accelerating
data accesses. MonetaD~\cite{monetad} and BankShot~\cite{BankShot} access
SSD devices directly from user space to eliminate the mode switch overhead.
FlexSC~\cite{FlexSC} tries to reduce the system call overhead,
and works like MegaPipe~\cite{MegaPipe} tries to move work to user space and
batch system calls to reduce mode switches. Volos~\cite{system-scm} argues
NVMM file system should be implemented largely as a user space library, rather
than as a kernel-level service. All the naming and indexing should be provided
in user-mode, the kernel is responsible only for NVMM protection and permission
management.

