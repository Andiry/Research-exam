% vim:tw=80:filetype=on:filetype=tex
\begin{abstract}

Non-volatile memories such as Phase Change Memory, Spin-Torque Transfer RAM
and Memristor are appearing on the horizon and soon they will sit on the
processor memory bus. These Non-volatile Main Memories (NVMM)
 will allow software to access persistent data with
extremely low latency and high bandwidth. However, existing storage
architectures introduce significant overhead that can dominate the low-latency
of persistent memories. As a matter of fact, new software accessing models
are required to exploit the performance of NVMM.

Besides, although accessing NVMM as persistent memory is a simple solution
 and provides good
 performance, current CPU cache hierarchy and write reordering compromise
the persistency of NVMM, and the slow latency and short endurance compared
to DRAM requires special system software design for NVMM.

In this paper, we investigate different software solutions to exploit
the performance potential of NVMM as well as its persistent property.
We divide approaches into four major categories: file system,
programming model, DRAM extensions and caching and acceleration. We
examine each category,  specify the challenges and opportunities NVMM brings
to system software design.
The paper also introduces our own work to accelerate storage access with
NVMM.

\end{abstract}


% a caching architecture that transparently caches
%user files on persistent memories and avoids most system call overheads
%by converting them into memory operations.


%When an application uses a system call to access a file
%on slower storage devices, \Chell{} intercepts
%the call and redirects the request to cache blocks in persistent memory,
%which reduces latency and increases bandwidth. To further reduce latency,
%\Chell{} also memory maps the cache blocks directly into an application's
%address space, allowing the application to access the cache via
%load/store operations
%without going to kernel. \Chell{} serve cache misses and eviction in the kernel
%to provide protection. We compare \Chell{} to conventional
%caching systems and find that \Chell{} can improve performance over page cache
%by up to 3.8\x{} for writes and 1.7\x{} for reads. 

















