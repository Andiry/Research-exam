\section{Background}
\label{sec:background}

Three emerging non-volatile memory technologies promise to provide fast,
 non-volatile, byte-addressable memories: spin-torque transfer RAM (STT-RAM),
phase change memory (PCM), and memristor-based memories. These new NVMs, also
termed \emph{storage-class memory}~\cite{scm}, have the potential to replace
the disks and change the storage hierarchy. In the following
sections we briefly introduce each of them, then we introduce the software
for NVMM and challenges they face.

\subsection{Non-volatile memory technologies}
\label{sec:hardware}

\textbf{Phase Change Memory} is a promising non-volatile byte-addressable
memory technology~\cite{PCM_EfficientMainMemory, PCMHierarchy}.
PCM is built with Chalcogenide-based materials, which has
two states, crystalline state and amorphous state. By
injecting current to heat the memory cell to a high temperature for a period
of time, the material crystallize and the resistence reduce. To reset the cell,
apply a large enough current for a short period to melt down the
material and it transition into amorphous state with higher resistence.
 These two states can be read as "1" and "0". As transition into crystalline
state requires longer current injection, PCM has slower writes comparing to
reads.  
As heating causes contraction of the cell, PCM has limited write endurance
up to $10^8$ cycles.
 
\textbf{Spin-Torque Transfer RAM} STT-RAM uses magnetic properties of 
certain materials and electric charges to enable different persistent states 
in memory cells. Each cell of STT-RAM has two ferromagnetic plates, with
one holds a particular polarity permanently, while the other can change the
polarity. If the two plates have the same polarity, the cell stores "1",
otherwise it stores "0". By applying a current STT-RAM can change the polarity
of the plate with soin-transfer torque.
STT-RAM promises potential of unlimited write cycles, and
current prototype using tunneling magnetorresistence showed 32ns for
read latency and 40ns for write latency, with 0.3mA power consumption
per cell~\cite{sttram}. The disadvantage of STT-RAM is shrinking cell size is
extremely difficult.

\textbf{Memristor memory} is a resistive RAM device~\cite{memristor}.
Applying electric field
changes the resistence of the memristor device, and different resistence level
can be read as 0 or 1. Recent research on memristor indicates that its
performance could be comparable to DRAM, with write endurance up to $10^{10}$
cycles. Currently memristor is still under development in the laboratory.
 
Some vendors have produced non-volatile main memory devices, they are
either small capacity and byte-addressable~\cite{micron-nvdimm},
or large capacity but block-addressable~\cite{smart-system}.
With emerging non-volatile technologies, we can expect
large capacity, byte-addressable NVMMs to appear.

\begin{table}
	\resizebox{\linewidth}{!}{
	\centering
	\begin{tabular}{|l|c|c|c|c|}
	\hline
%	\multirow{4}{*}{}&PMFS &\DAChell{}\\\hline
%	&\multicolumn{2}{c|}{(Ops per second)}\\\hline
	Item & DRAM & PCM & STT-RAM & Memristor \\\hline
	\hline
	Byte Addressable & Yes & Yes & Yes & Yes \\\hline
	Non-volatile & No & Yes & Yes & Yes \\\hline
	Read Time (ns) & 10 & 10-50 & 10-35 & ? \\\hline
	Write Time (ns) & 10 & 50-500 & 10-90 & ? \\\hline
	Endurance & $10^{15}$ & $10^{9}$ & $10^{15}$ & $10^{10}$ \\\hline
	\end{tabular}}
	\vspace*{1mm}
	\caption{\figtitle{Properties of Non-volatile memory technologies}}
	\label{table:techtrend}
\end{table}

\subsection{Challenges for NVMM software}
\label{sec:challenge}

Although NVMM is sitting on the system memory bus and can be accessed
via load and store operations like DRAM, its difference from DRAM
makes the NVMM software design needs to consider several special
characteristics:

\textbf{Performance} Traditional storage devices are sitting on I/O bus
(like SATA and USB) or high performance system bus such as PCIe. To access
them, applications need to pay the software overhead of mode switch, VFS and
block layer. For slow storage devices the software overhead is negligible,
but with NVMM the story is different. As NVMM has access latency close to
DRAM, the processors should access them directly via load and store
operations to fully exploit the NVMM performance.

\textbf{CPU caching hierarchy}
~\cite{CPUcaching} show the impact of CPU caching on the NVMM performance
and programming. Modern CPUs have store buffer to temporarily keep each store
to hide the latency of cache, and WC buffer to batch the writes before
flush to memory. Both store buffer and WC buffer are aiming to hide latency
and improve memory performance, but they also introduce problems on the
persistency of NVMM, and require programming changes on NVMM.

CPU uses write-back mode by default. In this mode stores are kept in cache
before writing to memory. To guarantee stores are committed to NVMM to achieve
persistency, applications must explicitly flush the cache lines for data
updates. This approach is not only error-prone~\cite{singlelock}
but also incurs significant
performance penalty. In contrast, write-through mode removes unnecessary
cache line flushes and reduce the software complexity, with write operations
cannot benefit from fast CPU cache.

\textbf{Write reordering} Modern processors may reorder write operations to improve
performance. This is not an issue for DRAM because the cache consistency
protocols provide all the processors with a consistent view of the memory.
However, out-of-order writes to NVMM may leave the software (for example,
file system) in an inconsistent state if a power failure occurs. Software
for NVMM must take caution of the consistency issue. 

To overcome the CPU caching and write reordering issue,
several solutions are proposed:

\begin{itemize}
\item Use write-through caching to make sure for each operation
data is flushed to the NVMM. This is a slow approach. 
\item Flush the entire cache when encounter a memory barrier. This solution
adds significant overhead to the performance.
\item Track the dirty cache lines and flush them accordingly. This is much
more efficient than flushing the entire cache, but may need software bookkeeping.
\item Use hardware primitives. This is the most efficient approach, but requires
hardware modifications.
\end{itemize}

Another inconsistency issue comes from the power failure during a single
write operation. If the write operation is not atomic, the data is left
in an inconsistent state. The common approaches to overcome the issue includes:

\begin{itemize}
\item Hardware atomic operations. This solution is simple but may require
hardware modifications.
\item Logging. Logging is a widely-used mechanism in file system and databases
to ensure write atomicity. There are two kinds of logging: Undo logging, which
saves the original value to the log and then update in place; Redo logging,
which write the new data to the log and then copy to the target place.
\item Copy-on-write operation. This is used in tree structure updates. Whenever
update the node, a new node is created and the pointer in the parent node is
updated atomically. This may result in cascade update up to the root.
\end{itemize}
%\textbf{Protection}

These challenges must be addressed in the NVMM system software design.
Researchers try to overcome these issues without sacrificing the performance
of NVMM, aiming at provide a fast, easy to use and robust system to users.


\subsection{Software for NVMM}
\label{sec:NVMM}

When non-volatile memory emerges, there have been researches about how to
integrate it into the system. They can be used to build solid state drives
instead of NAND flash, and NVM Express~\cite{NVMe} targets at accessing
non-volatile memory devices attached through the PCIe bus. However, due to
its byte-addressable and low-latency, high-bandwidth resemble to DRAM,
put them on the processor memory bus become the most reasonable solution
to fully exploit the performance of non-volatile memory.

Although using NVMM as system memory and access them like DRAM is simple,
this approach does not exploit the persistence property of NVMM. Also, the
high write latency and limited endurance comparing to DRAM makes NVMM not
suitable to replace DRAM direcly, and system software is necessary to
manage the NVMM.

Numerous researches propose different system software designs to
manage the NVMM. Typical solution can be divided into the following
four major categories:

\begin{itemize}
\item \textbf{File system} With the persistence property NVMM is suitable for
user data storage, and manage it with a file system to provide applications
fast access is a good way to utilize NVMM. NVMM file system is compatible
with POSIX API, does not require software modification, but need to take care
of the consistency issue.

\item \textbf{Programming model} Although NVMM file system is capable
 of exposing
the NVMM to the applications, the mode switch and VFS layer still adds
overhead. Some papers are investigating fast and safe accessing models of
NVMM, grant applications direct access to the NVMM. These solutions have
good performance but require software modifications.

\item \textbf{DRAM extension} With the low power comsumption and high density,
NVMM is a good extension to DRAM to increase the system memory size. These
researches focus on how to migrate memory pages between DRAM and NVMM.

\item \textbf{Caching and acceleration} With low-latency and high-bandwidth,
NVMM is able to work as a consistent cache for slower storage devices. As
DRAM is largely used as page cache today, using NVMM as cache has additional
benefits that it is persistent and does not to sync to disk as page cache
does.

\end{itemize}  

In this paper we introduce some major contributions of each categories
and describe them in details in the following sections.

