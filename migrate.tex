\section{NVMM/DRAM hybrid system design} 
\label{sec:migration}

Although NVMM has low power consumption and high density comparing to DRAM,
It is still not good enough to replace DRAM entirely due to the slow write
latency and low endurance. We expect in the future DRAM and NVMM
will reside on the system memory bus together.
Thus, how to utilize NVMM's persistency property while reduce the writes to
NVMM to hide the write latency and extend endurance becomes an interesting
topic and several researches contributes to this area.

In the hybrid system installed with both DRAM and NVMM, how to allocate
pages to exploit the performance of these two memories is a open question.
\cite{pcmalloc} allocate heap and stack segments with DRAM pages, and allocate
NVMM pages to other segments, because heap and stack segments are updated
frequently, while text segment is read only, and bss/data segments are
updated infrequently. These allocation mechanism allocates write-intensive
pages in DRAM and reduce the writes to NVMM. \textbf{PCM3D}~\cite{pcm3d}
combines the DRAM
and NVMM ares in a large flat memory region and migrate write-intensive pages
to DRAM. The migration is performed in operating system and target the
frequently written pages, while leave the read-intensive pages in NVMM.
\textbf{PDRAM}~\cite{pdram} introduces a hybrid PRAM and DRAM main memory
system, 
relies on a hardware memory controller to log the write counts to each page,
while a software module swap pages between DRAM and NVMM and does wear-leveling.
\textbf{RaPP}~\cite{RaPP} implements the page migration inside the memory
controller
to monitor access patterns and migrate pages between NVMM and DRAM. 
Mogul. et al~\cite{Mogul} describes the necessary operating system support for
NVM+DRAM hybrid main memory. The paper explores two possible NVM devices:
flash memory and PCM device to reside on the memory bus. As flash memory
is block-addressable with high write latency and low endurance, the paper
proposed that only read-only and read-heavy pages should be stored in flash
memory, and page is migrated between DRAM and flash memory. Also garbage
collection and wear leveling is needed. For PCM devices, the system design
is simpified as PCM is byte-addressable, garbage collection is no necessary
and wear-leveling is simpler. The paper concludes that for a hybrid main
memory system, OS should decide page migration issue to avoid endurance
problems and high write latency of NVMM devices.

\ignore{
\textbf{RaPP}~\cite{RaPP} implements the page migration inside the memory
controller
to monitor access patterns and migrate pages between NVMM and DRAM. Rapp
proposes a complicate memory controller design with a rank-based page
placement policy. Depending on the access patterns to pages, RaPP create
multiple page queues to store different rank page frames, place
performance-critical pages and frequently written pages in DRAM, place
non-critical pages and rarely written pages in PCM and spread writes
to PCM across many physical frames. By putting the page placement policy
inside memory controller, RaPP achieves better performance than software
solution, but with more sophisticated hardware design.
}

\textbf{Memorage}~\cite{memorage} argues that NVMM-based systems will have large
capacity of NVMM that need to be managed as both memory and storage in
an integrated manner to make the best performance and trade-offs. For exmaple,
fast, high-endurance SLC PCM can be used as main memory
while slow and low-endurance MLC PCM works as storage device.

Memorage manages both NVMM memory and storage resources, develops a dynamic
strategy to expand and shrink memory capacity according to system status. 
With large capacity NVMM sitting on memory bus, Memorage has two benefits:
1. When system is in low memory state, Memorage does not swap unused pages
to disk, instead it borrows pages from NVMM storage device to cope with
memory shortage.
2. As long as NVMM storage device has extra capacity, Memorage can use it
to relax the write endurance of NVMM main memory and facilitate wear-leveling.

\textbf{NVM Duet}~\cite{duet} provides flexible solution to the applications
which
have different expectations of NVMM: some are seeking the persistency, while
others just use NVMM as normal DRAM. As consistency is achieved via serializing
write operations and CPU cache flushing, differentiate between the two usages
makes sense to improve overall system performance.

NVM Duet provides a hardware/software interface that enables memory controller
to differentiate between the two types of NVMM usage as working memory and
persistent store. When NVMM is working as memory, CPU cache flushing is
eliminated as applications do not require persistency. Also memory controller
can fully exploit the bank-level parallelism while respecting the write order 
specified by programmers to guarantee the consistency of persistence store.
NVM Duet also proposes a new PCM architecture that provides dual retention
guarantees to meet the durability requirement of persistence store while relax
the retention requirement of working memory to reduce write latency. It also
applies a smart refresh mechanism to eliminate unnecessary refresh operations
by checking the resistance level. NVM Duet is another exmaple of exploiting
optimizations from the different NVMM usages.
