\section{Access model} 
\label{sec:access}

With the emergence of non-volatile memory, the accessing model needs
to be re-considered. Accessing non-volatile memory addresses several
challenges: how to create and manage non-volatile memory, how to ensure
consistency during system failures, and how to avoid common programming
bugs, such as dangling pointers, multiple free()s, and locking errors.

\nvh{}~\cite{nvheaps} and \mnem{}~\cite{mnemosyne} try to address these issues
and propose solutions to the non-volatile memory accessing models.

\nvh{} creates a lightweight system that exposes the performance of the
non-volatile memories and also ensures safety in the presence of
application and system failures by avoiding common programming errors.
It provides safe access to persistent objects with pointer safety and
flexible ACID transactions, and makes persistent objects easy to program.

\nvh{} is implemented as a C++ library under Linux. It manages
the NVMM with a memory allocator, and uses a gabbage collector to recycle
persistent objects. It also provides transaction support and atomic sections 
to provide concurrency and consistency against system failure.

\nvh{} addresses the volatile pointer and non-volatile pointer issue by
only allowing pointers within a single NV-Heap (intra-heap NV-to-NV pointers)
and pointers from volatile memory to a NV-Heap (V-to-NV pointers). This is
because pointers from an NV-Heap to volatile memory (NV-to-V pointers) do
not make sense when the system reboots, and inter-heap NV-to-NV pointers become
unsafe if the NV-Heap that contains the object is not available. By enforcing
this pointer restriction and checking pointers dynamically \nvh{} provides
pointer safety guarantee.

\nvh{} uses reference count to track dead objects and recycle them. When 
the reference count to an object reduces to zero, the deallocation routine 
atomically calls the destructor and deallocates the object. As the deallocation
is atomic, the deallocator can resume work after system failure without error.

\nvh{} uses undo log to provide ACID transaction support. Whenever application
wants to modify an object, \nvh{} makes a copy of the original object to
the write log and then updates the object. If system fails during
the transaction, \nvh{} rolls back the object to its original copy by using
the copy in the log.

\nvh{} exists as normal files in a file system, and it uses DAX
\texttt{mmap()} to map the NVMM pages directly into the application's
address space. Application must explicitly declare persistent objects in
\nvh{} and access the objects with caution. This adds overhead to the
programming but \nvh{} exerts to export simple interface for programmer
and hide the details.

\mnem{} is also addressing the management and persistency issue
of system failure for NVMM systems. \mnem{} provides three key services
that simplify the usage of NVMM. First, it provides \emph{persistent
memory regions}, which can be created automatically to store persistent 
variables or allocated dynamically. Second, \mnem{} provides persistence
primitives, low-level operations that support atomic data updates. Finally,
\mnem{} provides transaction support that enables consistent in-place
updates of persistent objects. \mnem{} does not provide type-safe pointers
and gabbage collection that \nvh{} provides, but it does not require
modification to the processor.

To bypass the CPU cache and makes writes to NVMM consistent, \mnem{} uses
\emph{write-through stores} that writes data to NVMM directly. It also
uses \emph{fense} to provide write ordering and \emph{flush} to flush
cacheline to the NVMM. \mnem{} uses redo logging to provide transaction support
as it does not require write ordering to log before every memory update.

\mnem{} consists of three parts: a kernel module to expose and virtualize NVMM, 
libraries to implement persistent regions and transaction system, and
a compiler to support persistent variables and transactions. To use \mnem{},
programmer uses \texttt{pstatic} to declare a persistent variable in the NVMM,
and calls \texttt{pmap} to tell \mnem{} to allocate persistent regions in NVMM
and map them to application's address space. From the view of programmer,
\mnem{} works similar to \nvh{}: they both require programmer to explicitly
declare persistent objects and modify their softwares.

\mnem{} has some limitations. It does not support persistent region sharing
between processes. Also it does not address the wearout issue of NVMM.

CDSMM~\cite{CDSMM} also presents the memory management module design for NVMMs.
Rather than performance, it focuses on security and protection: it introduces
techniques for 1) robust wear-aware memory allocation, 2) preventing for 
erroneous writes, and 3) consistency-perserving updates that are cache-efficient.

As hardware wear-leveling has performance issues, CDSMM presents a
software memory allocator that always allocate new blocks rather than reusing
old freed blocks to average the writes to each block. To reduce metadata
writes, CDSMM puts important information in DRAM and sync to NVMM only required.It also adds checksum to prevent stray writes from modifying metadata.

To protect NVMM pages CDSMM uses system call \texttt{mprotect}, but performs
it in a batch way so that to reduce mode switch overhead, kernel structure
modifying overhead and TLB flushes. CDSMM also proposes adding counter to CPU
cache line so that application can use command to track data is either in 
CPU cache or persistent on NVMM, and resolves the persistency and write ordering
issue. 

The disadvantage of CDSMM is that it requires both software and hardware
modifications, adds significant overhead to software programming. The paper
shows a B+ tree example and in order to apply CDSMM design, it does not only 
adds much more software efforts, but also change the definition of B+ tree:
the values in a node is not in sorted order and it takes linear time to search
value in a node. CDSMM has several interesting ideas about NVMM protection, but
to integrate the design in applications is still difficult.

